<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Gesture AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #007bff;
            --surface: #ffffff;
            --background: #f0f2f5;
            --text-main: #202124;
            --text-secondary: #5f6368;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background: var(--background);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Camera Container */
        .camera-container {
            position: relative;
            width: 100%;
            height: 60vh; /* Takes up top 60% of screen */
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1); /* Mirror match video */
        }

        /* Overlay for loading state */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            color: white;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Info Card Area */
        .info-panel {
            flex: 1;
            background: var(--surface);
            border-top-left-radius: 24px;
            border-top-right-radius: 24px;
            padding: 24px;
            margin-top: -20px; /* Overlap camera slightly */
            z-index: 5;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .gesture-icon {
            font-size: 48px;
            margin-bottom: 10px;
            height: 60px;
        }

        .gesture-title {
            font-size: 24px;
            font-weight: 700;
            margin: 0 0 10px 0;
            color: var(--primary);
        }

        .gesture-desc {
            font-size: 16px;
            line-height: 1.5;
            color: var(--text-secondary);
            max-width: 500px;
        }

        .confidence-meter {
            margin-top: 15px;
            font-size: 12px;
            color: #888;
            background: #eee;
            padding: 4px 12px;
            border-radius: 12px;
        }

        /* Floating Label on Camera */
        .floating-label {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            backdrop-filter: blur(4px);
            z-index: 4;
            display: none; /* Hidden until gesture found */
        }
    </style>
</head>
<body>

    <!-- Camera View -->
    <div class="camera-container">
        <video id="webcam" playsinline autoplay></video>
        <canvas id="output_canvas"></canvas>
        <div id="gesture_label" class="floating-label">None</div>
        
        <!-- Loading / Start Overlay -->
        <div id="loading_overlay" class="overlay">
            <div class="spinner"></div>
            <p id="status_text">Loading AI Model...</p>
            <button id="enable_cam_btn" style="display:none;">Enable Camera</button>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
        <div id="icon_display" class="gesture-icon">ðŸ‘‹</div>
        <h2 id="title_display" class="gesture-title">Waiting for Hand...</h2>
        <p id="desc_display" class="gesture-desc">
            Place your hand in front of the camera. The AI will analyze your gesture and explain its meaning here.
        </p>
        <div id="confidence_display" class="confidence-meter">Confidence: 0%</div>
    </div>

    <!-- MediaPipe Import -->
    <script type="module">
        import {
            GestureRecognizer,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const overlay = document.getElementById("loading_overlay");
        const statusText = document.getElementById("status_text");
        const enableBtn = document.getElementById("enable_cam_btn");
        
        // UI Elements
        const titleDisplay = document.getElementById("title_display");
        const descDisplay = document.getElementById("desc_display");
        const iconDisplay = document.getElementById("icon_display");
        const confDisplay = document.getElementById("confidence_display");
        const floatLabel = document.getElementById("gesture_label");

        let gestureRecognizer;
        let runningMode = "VIDEO";
        let lastVideoTime = -1;
        let isWebcamActive = false;

        // Content Database
        const gestureData = {
            "None": {
                icon: "ðŸ‘‹",
                title: "No Gesture Detected",
                desc: "Move your hand closer or ensure good lighting. The AI is looking for landmarks on your fingers and palm."
            },
            "Closed_Fist": {
                icon: "âœŠ",
                title: "Closed Fist",
                desc: "A symbol of solidarity, strength, or defiance. In rock-paper-scissors, this is 'Rock'. It represents holding onto something tightly."
            },
            "Open_Palm": {
                icon: "âœ‹",
                title: "Open Palm",
                desc: "A universal sign of greeting, stopping, or openness. It shows you have nothing to hide. In rock-paper-scissors, this is 'Paper'."
            },
            "Pointing_Up": {
                icon: "â˜ï¸",
                title: "Pointing Up",
                desc: "Used to indicate direction, ask a question, or emphasize a point. It draws attention to something important above."
            },
            "Thumb_Down": {
                icon: "ðŸ‘Ž",
                title: "Thumbs Down",
                desc: "A gesture of disapproval or disagreement. Historically associated with voting against something in Roman gladiator games."
            },
            "Thumb_Up": {
                icon: "ðŸ‘",
                title: "Thumbs Up",
                desc: "The universal sign for 'Good', 'Okay', or approval. It indicates success or agreement with a situation."
            },
            "Victory": {
                icon: "âœŒï¸",
                title: "Victory / Peace",
                desc: "The 'V' sign. Depending on context, it means Victory or Peace. Popularized in the 1960s as a symbol of the counterculture."
            },
            "ILoveYou": {
                icon: "ðŸ¤Ÿ",
                title: "I Love You",
                desc: "From American Sign Language (ASL). It combines the letters I, L, and Y using the pinky, index finger, and thumb."
            }
        };

        // 1. Initialize MediaPipe Gesture Recognizer
        const createGestureRecognizer = async () => {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath:
                            "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                        delegate: "GPU"
                    },
                    runningMode: runningMode,
                    numHands: 1 // Optimize for speed on mobile
                });
                
                statusText.innerText = "AI Ready. Start Camera?";
                overlay.querySelector(".spinner").style.display = "none";
                enableBtn.style.display = "inline-block";
                
            } catch (error) {
                statusText.innerText = "Error loading AI: " + error.message;
                console.error(error);
            }
        };

        createGestureRecognizer();

        // 2. Enable Webcam
        const enableCam = () => {
            if (!gestureRecognizer) {
                alert("Please wait for the model to load");
                return;
            }

            // iOS/Android constraint: getUserMedia requires HTTPS or localhost
            const constraints = {
                video: {
                    facingMode: "user", // Front camera
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
                overlay.style.display = "none";
                isWebcamActive = true;
            }).catch((err) => {
                console.error(err);
                alert("Camera access denied or not supported. Please ensure you are running on HTTPS or localhost.");
            });
        };

        enableBtn.addEventListener("click", enableCam);

        // 3. Prediction Loop
        async function predictWebcam() {
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
            }

            // Resize canvas to match video stream
            if (video.videoWidth > 0 && video.videoHeight > 0) {
                canvasElement.width = video.videoWidth;
                canvasElement.height = video.videoHeight;
                
                // Mirror logic is handled in CSS, so we draw normally here
                let nowInMs = Date.now();
                if (video.currentTime !== lastVideoTime) {
                    lastVideoTime = video.currentTime;
                    
                    const results = gestureRecognizer.recognizeForVideo(video, nowInMs);

                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    
                    if (results.landmarks) {
                        // Draw skeletal lines
                        const drawingUtils = new DrawingUtils(canvasCtx);
                        for (const landmarks of results.landmarks) {
                            drawingUtils.drawConnectors(
                                landmarks,
                                GestureRecognizer.HAND_CONNECTIONS,
                                { color: "#00FF00", lineWidth: 3 }
                            );
                            drawingUtils.drawLandmarks(landmarks, {
                                color: "#FF0000",
                                lineWidth: 2,
                                radius: 3
                            });
                        }
                    }

                    // Process Gestures
                    if (results.gestures.length > 0) {
                        const gesture = results.gestures[0][0];
                        const categoryName = gesture.categoryName;
                        const score = Math.round(gesture.score * 100);

                        updateUI(categoryName, score);
                    } else {
                        updateUI("None", 0);
                    }
                    canvasCtx.restore();
                }
            }

            if (isWebcamActive) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        // 4. Update UI with Data
        let currentGesture = "";
        
        function updateUI(category, score) {
            // Debounce slightly or just update if changed
            if (category === currentGesture && category !== "None") {
                confDisplay.innerText = `Confidence: ${score}%`;
                return;
            }
            
            currentGesture = category;
            const data = gestureData[category] || gestureData["None"];

            titleDisplay.innerText = data.title;
            descDisplay.innerText = data.desc;
            iconDisplay.innerText = data.icon;
            confDisplay.innerText = score > 0 ? `Confidence: ${score}%` : "";
            
            // Update floating label on video
            if (category !== "None") {
                floatLabel.style.display = "block";
                floatLabel.innerText = `${data.title} ${data.icon}`;
            } else {
                floatLabel.style.display = "none";
            }
        }

    </script>
</body>
</html>
